/* Generated by re2c 3.1 */
#line 1 "source/intl_plural_expr.re"
// -*- c++ -*-

// The SEL extension library
// Free software published under the MIT license.

#line 28 "source/intl_plural_expr.re"


static const char *get_next_token(
    const char *cursor, const char *limit, int *tok, std::unique_ptr<expr> &minor)
{
    const char *p1, *p2;
    
#line 17 "source/intl_plural_expr.re.ipp"
const char *yyt1;
#line 34 "source/intl_plural_expr.re"


    minor.reset();

    begin:


#line 27 "source/intl_plural_expr.re.ipp"
{
	int yych;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '\t':
		case '\n':
		case '\v':
		case '\f':
		case '\r':
		case ' ': goto yy3;
		case '!': goto yy5;
		case '%': goto yy7;
		case '&': goto yy8;
		case '(': goto yy9;
		case ')': goto yy10;
		case '*': goto yy11;
		case '+': goto yy12;
		case '-': goto yy13;
		case '/': goto yy14;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			yyt1 = cursor;
			goto yy15;
		case ':': goto yy17;
		case '<': goto yy18;
		case '=': goto yy20;
		case '>': goto yy21;
		case '?': goto yy23;
		case 'n': goto yy24;
		case '|': goto yy25;
		default:
			if (limit - cursor < 1) goto yy32;
			goto yy1;
	}
yy1:
	++cursor;
yy2:
#line 82 "source/intl_plural_expr.re"
	{ return nullptr; }
#line 75 "source/intl_plural_expr.re.ipp"
yy3:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '\t':
		case '\n':
		case '\v':
		case '\f':
		case '\r':
		case ' ': goto yy3;
		default: goto yy4;
	}
yy4:
#line 43 "source/intl_plural_expr.re"
	{ goto begin; }
#line 91 "source/intl_plural_expr.re.ipp"
yy5:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '=': goto yy26;
		default: goto yy6;
	}
yy6:
#line 77 "source/intl_plural_expr.re"
	{ *tok = NOT; return cursor; }
#line 102 "source/intl_plural_expr.re.ipp"
yy7:
	++cursor;
#line 74 "source/intl_plural_expr.re"
	{ *tok = MOD; return cursor; }
#line 107 "source/intl_plural_expr.re.ipp"
yy8:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '&': goto yy27;
		default: goto yy2;
	}
yy9:
	++cursor;
#line 61 "source/intl_plural_expr.re"
	{ *tok = LPAREN; return cursor; }
#line 119 "source/intl_plural_expr.re.ipp"
yy10:
	++cursor;
#line 62 "source/intl_plural_expr.re"
	{ *tok = RPAREN; return cursor; }
#line 124 "source/intl_plural_expr.re.ipp"
yy11:
	++cursor;
#line 72 "source/intl_plural_expr.re"
	{ *tok = TIMES; return cursor; }
#line 129 "source/intl_plural_expr.re.ipp"
yy12:
	++cursor;
#line 70 "source/intl_plural_expr.re"
	{ *tok = PLUS; return cursor; }
#line 134 "source/intl_plural_expr.re.ipp"
yy13:
	++cursor;
#line 71 "source/intl_plural_expr.re"
	{ *tok = MINUS; return cursor; }
#line 139 "source/intl_plural_expr.re.ipp"
yy14:
	++cursor;
#line 73 "source/intl_plural_expr.re"
	{ *tok = DIVIDE; return cursor; }
#line 144 "source/intl_plural_expr.re.ipp"
yy15:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy15;
		default: goto yy16;
	}
yy16:
	p1 = yyt1;
	p2 = cursor;
#line 46 "source/intl_plural_expr.re"
	{
    uint64_t value = 0;
    for (const char *p = p1; p != p2; ++p)
    {
        unsigned int digit = *p - '0';
        if (value > UINT64_MAX / 10 || UINT64_MAX - 10 * value < digit)
            return nullptr;
        value = 10 * value + digit;
    }

    *tok = INTEGER;
    minor.reset(new expr(et_value, value));
    return cursor;
}
#line 179 "source/intl_plural_expr.re.ipp"
yy17:
	++cursor;
#line 79 "source/intl_plural_expr.re"
	{ *tok = COLON; return cursor; }
#line 184 "source/intl_plural_expr.re.ipp"
yy18:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '=': goto yy28;
		default: goto yy19;
	}
yy19:
#line 69 "source/intl_plural_expr.re"
	{ *tok = LT; return cursor; }
#line 195 "source/intl_plural_expr.re.ipp"
yy20:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '=': goto yy29;
		default: goto yy2;
	}
yy21:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '=': goto yy30;
		default: goto yy22;
	}
yy22:
#line 68 "source/intl_plural_expr.re"
	{ *tok = GT; return cursor; }
#line 213 "source/intl_plural_expr.re.ipp"
yy23:
	++cursor;
#line 78 "source/intl_plural_expr.re"
	{ *tok = QUESTION; return cursor; }
#line 218 "source/intl_plural_expr.re.ipp"
yy24:
	++cursor;
#line 63 "source/intl_plural_expr.re"
	{ *tok = VARN; return cursor; }
#line 223 "source/intl_plural_expr.re.ipp"
yy25:
	++cursor;
	yych = cursor < limit ? (unsigned char)*cursor : 0;
	switch (yych) {
		case '|': goto yy31;
		default: goto yy2;
	}
yy26:
	++cursor;
#line 65 "source/intl_plural_expr.re"
	{ *tok = NE; return cursor; }
#line 235 "source/intl_plural_expr.re.ipp"
yy27:
	++cursor;
#line 75 "source/intl_plural_expr.re"
	{ *tok = AND; return cursor; }
#line 240 "source/intl_plural_expr.re.ipp"
yy28:
	++cursor;
#line 67 "source/intl_plural_expr.re"
	{ *tok = LE; return cursor; }
#line 245 "source/intl_plural_expr.re.ipp"
yy29:
	++cursor;
#line 64 "source/intl_plural_expr.re"
	{ *tok = EQ; return cursor; }
#line 250 "source/intl_plural_expr.re.ipp"
yy30:
	++cursor;
#line 66 "source/intl_plural_expr.re"
	{ *tok = GE; return cursor; }
#line 255 "source/intl_plural_expr.re.ipp"
yy31:
	++cursor;
#line 76 "source/intl_plural_expr.re"
	{ *tok = OR; return cursor; }
#line 260 "source/intl_plural_expr.re.ipp"
yy32:
#line 81 "source/intl_plural_expr.re"
	{ *tok = 0; return cursor; }
#line 264 "source/intl_plural_expr.re.ipp"
}
#line 84 "source/intl_plural_expr.re"

}
